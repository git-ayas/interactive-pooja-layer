<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>Interactive pooja thaali</title>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
		integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
		integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
		crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
		integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
		crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
		integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
		crossorigin="anonymous"></script>
		<script src="./libs/hammer.min.js"></script>
	<style>
		body {
			margin: 0;
			height: 100%;
		}

		canvas {
			width: 100%;
			height: 100%;
			opacity: 1.6;
		}

		#backdrop {
			background: black;
			height: 1800px;
			z-index: -1;
		}

		#interactiveLayer {
			margin-top: -1800px;

		}
	</style>
</head>

<body>
	<div id="backdrop" class="col-md-12">
		<span class="vrdevotee-player">
			
		</span>
		<!-- <iframe width="100%" height="100%" src="https://www.youtube.com/embed/_oOQ5UYKAKo?autoplay=1" frameborder="0"
			allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> -->

	</div>
	<div id="interactiveLayer"></div>
<script src="index.js" type="module"></script>
	<!-- <script defer type="module">
		import * as THREE from './libs/three.module.js'
		window.requestAnimFrame = (function () {
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function (/* function */ callback, /* DOMElement */ element) {
					window.setTimeout(callback, 1000 / 60);
				};
		})();
		var camera, scene, renderer;
		var plane;
		var mouse, raycaster, isShiftDown = false;
		var particleSystem;// create the particle variables
		var particleCount = 800,
			particles = new THREE.Geometry(),
			pMaterial = new THREE.PointsMaterial({
				color: 0xFFFFFF,
				size: 20,
				map: new THREE.TextureLoader().load(
					"textures/particle.png"
				),
			blending: new THREE.,
				transparent: true
			});

		var rollOverMesh, rollOverMaterial;
		var cubeGeo, cubeMaterial;
		var followMouse = false;
		var objects = [];
		init();
		render();
		function init() {
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(0, 1000, 0);
			camera.lookAt(0, 0, 0);
			scene = new THREE.Scene();
			//scene.background = new THREE.Color(0xf0f0f0);
			//scene.background = new THREE.Color(0x000000);

			scene.transparent = true;

			// roll-over helpers
			var rollOverGeo = new THREE.PlaneGeometry(200, 75, 75);
			rollOverGeo.rotateX(-Math.PI / 2);

			rollOverMaterial = new THREE.MeshLambertMaterial({
				color: null,
				map: new THREE.TextureLoader().load('textures/pooja-thaali.png'),
				transparent: true
			});

			rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
			rollOverMesh.overdraw = true;
			scene.add(rollOverMesh);
			// cubes
			cubeGeo = new THREE.BoxBufferGeometry(50, 50, 50);
			cubeMaterial = new THREE.MeshLambertMaterial(
				{
					color: 0xfeb74c,
					map: new THREE.TextureLoader().load('textures/square-outline-textured.png')
				});
			// grid
			var gridHelper = new THREE.GridHelper(1000, 20);
			//scene.add(gridHelper);
			//
			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();
			var geometry = new THREE.PlaneBufferGeometry(1000, 1000);
			geometry.rotateX(- Math.PI / 2);
			plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ visible: false }));
			scene.add(plane);
			objects.push(plane);


			// now create the individual particles
			for (var p = 0; p < particleCount; p++) {

				// create a particle with random
				// position values, -250 -> 250
				var pX = Math.random() * 500 - 250,
					pY = Math.random() * 500 - 250,
					pZ = Math.random() * 500 - 250,
					particle = new THREE.Vector3(pX, pY, pZ);

				// create a velocity vector
				particle.velocity = new THREE.Vector3(
					0,				// x
					-Math.random(),	// y
					0);				// z


				// add it to the geometry
				particles.vertices.push(particle);
			}

			// create the particle system
			particleSystem = new THREE.Points(
				particles,
				pMaterial);
			// also update the particle system to
			// sort the particles which enables
			// the behaviour we want
			particleSystem.sortParticles = true;



			// add it to the scene
			scene.add(particleSystem);


			// lights
			var ambientLight = new THREE.AmbientLight(0x606060);
			scene.add(ambientLight);
			var directionalLight = new THREE.DirectionalLight(0xffffff);
			directionalLight.position.set(1, 0.75, 0.5).normalize();
			scene.add(directionalLight);
			renderer = new THREE.WebGLRenderer({ alpha: true });
			renderer.setClearColor(0xffffff, 0);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('interactiveLayer').appendChild(renderer.domElement)
			//document.body.appendChild( renderer.domElement );
			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mousedown', onDocumentMouseDown, false);
			document.addEventListener('keydown', onDocumentKeyDown, false);
			document.addEventListener('keyup', onDocumentKeyUp, false);
			//
			window.addEventListener('resize', onWindowResize, false);
		}
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}
		function onDocumentMouseMove(event) {
			event.preventDefault();
			mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects(objects);
			if (intersects.length > 0) {
				var intersect = intersects[0];
				if (followMouse) {
					rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
					rollOverMesh.position.divideScalar(1).floor().multiplyScalar(1).addScalar(1);
				} else {
					resetThaaliPos();
				}


			}
			

			render();
		}
		function resetThaaliPos() {
			rollOverMesh.position.set(-270, 1, 240);

		}
		// animation loop
		function updateParticle() {

			// add some rotation to the system
			particleSystem.rotation.y += 0.01;

			var pCount = particleCount;
			while (pCount--) {
				// get the particle
				var particle = particles.vertices[pCount];
				
				// check if we need to reset
				if (particle.y < -200) {
					particle.y = 200;
					particle.velocity.y = 0;
				}

				// update the velocity
				particle.velocity.y -= Math.random() * .1;

				// and the position
				particle.add(
					particle.velocity);
			}

			// flag to the particle system that we've
			// changed its vertices. This is the
			// dirty little secret.
			particleSystem.geometry.__dirtyVertices = true;

			renderer.render(scene, camera);

			// set up the next call
			requestAnimFrame(updateParticle);
		}
		function onDocumentMouseDown(event) {
			followMouse = false;
			resetThaaliPos();

			event.preventDefault();
			mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects(objects);

			if (intersects.length > 0) {
				var intersect = intersects[0];
				var currentPoint = intersect.point;
				if ((currentPoint.x > -360) && (currentPoint.x < -180)) {
					if ((currentPoint.z > 200) && (currentPoint.x < 280)) {
						followMouse = true;
					}
				}
			}
			updateParticle();
			return;
			if (intersects.length > 0) {
				var intersect = intersects[0];
				// delete cube
				if (isShiftDown) {
					if (intersect.object !== plane) {
						scene.remove(intersect.object);
						objects.splice(objects.indexOf(intersect.object), 1);
					}
					// create cube
				} else {
					var voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
					voxel.position.copy(intersect.point).add(intersect.face.normal);
					voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
					scene.add(voxel);
					objects.push(voxel);
				}
				render();
			}
		}
		function onDocumentKeyDown(event) {
			switch (event.keyCode) {
				case 16: isShiftDown = true; break;
			}
		}
		function onDocumentKeyUp(event) {
			switch (event.keyCode) {
				case 16: isShiftDown = false; break;
			}
		}
		function render() {
			renderer.render(scene, camera);
		}
	</script> -->
</body>

</html>